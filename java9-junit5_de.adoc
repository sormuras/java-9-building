==== #WorksFineOnJDK9

JUnit 5 unterstützt seit der Version 5.0.0 die Verwendung unter Java 9.
Einerseits wird keine verbotene und bald unerreichbare Java API, wie `sun.misc.Unsafe` oder andere _Illegal Reflective Access_ Hacks, verwendet.
Andererseits enthalten alle veröffentlichten Artefakte [1][2] ein eindeutiges `Automatic-Module-Name` Attribut in ihrem JAR Manifest.
So ist zum Beispiel in der Datei `junit-jupiter-api-5.0.0.jar` der Modulname `org.junit.jupiter.api` festgehalten.
Unter diesem "reverse DNS" Namen kann man unter Java 9 das Jupiter API Modul eindeutig referenzieren.

```java
module com.foo.bar {
  requires org.junit.jupiter.api;
}
```

Zur Zeit sind die JUnit 5 Artefakte nur als "automatische Module" verwendbar.
Das heißt, sie enthalten keine konkrete Modulbeschreibungsklasse namens `module-info.class`.
Damit sind automatisch alle Pakete eines Artefakts les- und verwendbar, auch die, die wir nicht öffentlich verfügbar machen wollen.
Das wird sich in einer zukünftigen JUnit 5 Version ändern.
Deshalb bitte keine mit `@API(Status.INTERNAL)` annotierte Klasse verwenden.

==== Tests in Modulen organisieren

Im Umfeld des Java-Modulsystems gibt es zunächst zwei Arten von Typen.
Zum Einen gibt es Modul-interne Typen, die sich untereinander mit den bekannten Regeln referenzieren können.
`public`, `protected`, `private` und _package private_ sind hier die Schlagworte.
Zum Anderen gibt es nun die Teilmenge der `public`-annotierten Typen, die sich in veröffentlichten Paketen befinden:

```java
module alpha {
  exports alpha.api;
}
```

Damit sind alle Typen aus dem Paket `alpha.api` für andere Module lesbar.
Alle Typen aus anderen Paketen, wie zum Beispiel `package alpha.api.internal`, können von anderen Modulen nicht gelesen werden.

Diese Zweiteilung spiegelt sich beim Testen wider.
Es gibt solche Tests, die sich an die strikten Grenzen halten und solche, die die Grenzen absichtlich missachten um interne Typen zu testen.

===== Echte Tests

_nur Zugriff auf die exportierten Typen, die strikten Modulgrenzen werden respektiert_

Dafür erweitern wir das erste Beispiel um zwei Elemente.
Zunächst öffnen wir das Modul `com.foo.bar` mittels `open module`.
Damit ermöglichen wir den generellen, reflektiven Zugriff auf alle im Module enthaltene Pakete.

Als Zweites fügen wir `requires alpha;` der Modulbeschreibung hinzu.
Diese sieht nun so aus:

```java
open module com.foo.bar {
  requires alpha;
  requires org.junit.jupiter.api;
}
```

Alle Tests, die im Modul `com.foo.bar` enthalten sind, ausführen:

```java
java --module-path mods/test:mods/main:mods/deps
     --add-modules com.foo.bar
     --module org.junit.platform.console
     --select-module com.foo.bar
```

Alle Tests aus allen Modulen, die im `module-path` aufgeführt sind, ausführen:

```java
java --module-path mods/test:mods/main:mods/deps
     --add-modules ALL-MODULE-PATH
     --module org.junit.platform.console
     --scan-module-path
```
===== Modul-interne Tests

_genau wie früher auf dem `class-path`, mit Zugriff auf `package private` und `protected` deklarierte Typen_

Modul-interne Tests können mittels `--patch-module module=file(;file)*` ausgeführt werden:

```java
java --module-path mods/test:mods/deps
     --patch-module mods/test=mods/main (TODO!)
     --add-modules ALL-MODULE-PATH
     --module org.junit.platform.console
     --scan-module-path
```

// Ideen aus `junit5-java9-modulepath` holen bzw. beschreiben

https://github.com/junit-team/junit5-samples/pull/46/files

==== Die Eismaschine

Oder wie implementiert und registriert man eine eigene `TestEngine` mit Java 9?

// Text aus `junit5-java9-engine` übersetzen

https://github.com/junit-team/junit5-samples/blob/master/junit5-java9-engine/README.md

==== Links
- [1]: http://junit.org/junit5/docs/current/user-guide/#dependency-metadata
- [2]: https://github.com/junit-team/junit5#dependency-metadata